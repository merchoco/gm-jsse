package cn.gmssl.security.util;

import java.util.ListResourceBundle;

public class Resources_ko extends ListResourceBundle {
   private static final Object[][] contents = new Object[][]{{"SPACE", " "}, {"2SPACE", "  "}, {"6SPACE", "      "}, {"COMMA", ", "}, {"NEWLINE", "\n"}, {"STAR", "*******************************************"}, {"STARNN", "*******************************************\n\n"}, {".OPTION.", " [옵션]..."}, {"Options.", "옵션:"}, {"Use.keytool.help.for.all.available.commands", "사용 가능한 모든 명령에 \"keytool -help\" 사용"}, {"Key.and.Certificate.Management.Tool", "키 및 인증서 관리 툴"}, {"Commands.", "명령:"}, {"Use.keytool.command.name.help.for.usage.of.command.name", "command_name 사용법에 \"keytool -command_name -help\" 사용"}, {"Generates.a.certificate.request", "인증서 요청을 생성합니다."}, {"Changes.an.entry.s.alias", "항목의 별칭을 변경합니다."}, {"Deletes.an.entry", "항목을 삭제합니다."}, {"Exports.certificate", "인증서를 익스포트합니다."}, {"Generates.a.key.pair", "키 쌍을 생성합니다."}, {"Generates.a.secret.key", "보안 키를 생성합니다."}, {"Generates.certificate.from.a.certificate.request", "인증서 요청에서 인증서를 생성합니다."}, {"Generates.CRL", "CRL을 생성합니다."}, {"Imports.entries.from.a.JDK.1.1.x.style.identity.database", "JDK 1.1.x 스타일 ID 데이터베이스에서 항목을 임포트합니다."}, {"Imports.a.certificate.or.a.certificate.chain", "인증서 또는 인증서 체인을 임포트합니다."}, {"Imports.one.or.all.entries.from.another.keystore", "다른 키 저장소에서 하나 또는 모든 항목을 임포트합니다."}, {"Clones.a.key.entry", "키 항목을 복제합니다."}, {"Changes.the.key.password.of.an.entry", "항목의 키 비밀번호를 변경합니다."}, {"Lists.entries.in.a.keystore", "키 저장소의 항목을 나열합니다."}, {"Prints.the.content.of.a.certificate", "인증서의 콘텐츠를 인쇄합니다."}, {"Prints.the.content.of.a.certificate.request", "인증서 요청의 콘텐츠를 인쇄합니다."}, {"Prints.the.content.of.a.CRL.file", "CRL 파일의 콘텐츠를 인쇄합니다."}, {"Generates.a.self.signed.certificate", "자체 서명된 인증서를 생성합니다."}, {"Changes.the.store.password.of.a.keystore", "키 저장소의 저장소 비밀번호를 변경합니다."}, {"alias.name.of.the.entry.to.process", "처리할 항목의 별칭 이름"}, {"destination.alias", "대상 별칭"}, {"destination.key.password", "대상 키 비밀번호"}, {"destination.keystore.name", "대상 키 저장소 이름"}, {"destination.keystore.password.protected", "대상 키 저장소 비밀번호로 보호됨"}, {"destination.keystore.provider.name", "대상 키 저장소 제공자 이름"}, {"destination.keystore.password", "대상 키 저장소 비밀번호"}, {"destination.keystore.type", "대상 키 저장소 유형"}, {"distinguished.name", "식별 이름"}, {"X.509.extension", "X.509 확장"}, {"output.file.name", "출력 파일 이름"}, {"input.file.name", "입력 파일 이름"}, {"key.algorithm.name", "키 알고리즘 이름"}, {"key.password", "키 비밀번호"}, {"key.bit.size", "키 비트 크기"}, {"keystore.name", "키 저장소 이름"}, {"new.password", "새 비밀번호"}, {"do.not.prompt", "확인하지 않음"}, {"password.through.protected.mechanism", "보호되는 메커니즘을 통한 비밀번호"}, {"provider.argument", "제공자 인수"}, {"provider.class.name", "제공자 클래스 이름"}, {"provider.name", "제공자 이름"}, {"provider.classpath", "제공자 클래스 경로"}, {"output.in.RFC.style", "RFC 스타일의 출력"}, {"signature.algorithm.name", "서명 알고리즘 이름"}, {"source.alias", "소스 별칭"}, {"source.key.password", "소스 키 비밀번호"}, {"source.keystore.name", "소스 키 저장소 이름"}, {"source.keystore.password.protected", "소스 키 저장소 비밀번호로 보호됨"}, {"source.keystore.provider.name", "소스 키 저장소 제공자 이름"}, {"source.keystore.password", "소스 키 저장소 비밀번호"}, {"source.keystore.type", "소스 키 저장소 유형"}, {"SSL.server.host.and.port", "SSL 서버 호스트 및 포트"}, {"signed.jar.file", "서명된 jar 파일"}, {"certificate.validity.start.date.time", "인증서 유효 기간 시작 날짜/시간"}, {"keystore.password", "키 저장소 비밀번호"}, {"keystore.type", "키 저장소 유형"}, {"trust.certificates.from.cacerts", "cacerts의 보안 인증서"}, {"verbose.output", "상세 정보 출력"}, {"validity.number.of.days", "유효 기간 일 수"}, {"Serial.ID.of.cert.to.revoke", "철회할 인증서의 일련 ID"}, {"keytool.error.", "keytool 오류: "}, {"Illegal.option.", "잘못된 옵션:   "}, {"Illegal.value.", "잘못된 값: "}, {"Unknown.password.type.", "알 수 없는 비밀번호 유형: "}, {"Cannot.find.environment.variable.", "환경 변수를 찾을 수 없음: "}, {"Cannot.find.file.", "파일을 찾을 수 없음: "}, {"Command.option.flag.needs.an.argument.", "명령 옵션 {0}에 인수가 필요합니다."}, {"Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.", "경고: 다른 저장소 및 키 비밀번호는 PKCS12 KeyStores에 대해 지원되지 않습니다. 사용자가 지정한 {0} 값을 무시하는 중입니다."}, {".keystore.must.be.NONE.if.storetype.is.{0}", "-storetype이 {0}인 경우 -keystore는 NONE이어야 합니다."}, {"Too.many.retries.program.terminated", "재시도 횟수가 너무 많아 프로그램이 종료되었습니다."}, {".storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}", "-storetype이 {0}인 경우 -storepasswd 및 -keypasswd 명령이 지원되지 않습니다."}, {".keypasswd.commands.not.supported.if.storetype.is.PKCS12", "-storetype이 PKCS12인 경우 -keypasswd 명령이 지원되지 않습니다."}, {".keypass.and.new.can.not.be.specified.if.storetype.is.{0}", "-storetype이 {0}인 경우 -keypass 및 -new를 지정할 수 없습니다."}, {"if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified", "-protected를 지정한 경우 -storepass, -keypass 및 -new를 지정하지 않아야 합니다."}, {"if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified", "-srcprotected를 지정한 경우 -srcstorepass 및 -srckeypass를 지정하지 않아야 합니다."}, {"if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified", "키 저장소가 비밀번호로 보호되지 않는 경우 -storepass, -keypass 및 -new를 지정하지 않아야 합니다."}, {"if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified", "소스 키 저장소가 비밀번호로 보호되지 않는 경우 -srcstorepass 및 -srckeypass를 지정하지 않아야 합니다."}, {"Illegal.startdate.value", "startdate 값이 잘못되었습니다."}, {"Validity.must.be.greater.than.zero", "유효 기간은 0보다 커야 합니다."}, {"provName.not.a.provider", "{0}은(는) 제공자가 아닙니다."}, {"Usage.error.no.command.provided", "사용법 오류: 명령을 입력하지 않았습니다."}, {"Source.keystore.file.exists.but.is.empty.", "소스 키 저장소 파일이 존재하지만 비어 있음: "}, {"Please.specify.srckeystore", "-srckeystore를 지정하십시오."}, {"Must.not.specify.both.v.and.rfc.with.list.command", "'list' 명령에 -v와 -rfc를 함께 지정하지 않아야 합니다."}, {"Key.password.must.be.at.least.6.characters", "키 비밀번호는 6자 이상이어야 합니다."}, {"New.password.must.be.at.least.6.characters", "새 비밀번호는 6자 이상이어야 합니다."}, {"Keystore.file.exists.but.is.empty.", "키 저장소 파일이 존재하지만 비어 있음: "}, {"Keystore.file.does.not.exist.", "키 저장소 파일이 존재하지 않음: "}, {"Must.specify.destination.alias", "대상 별칭을 지정해야 합니다."}, {"Must.specify.alias", "별칭을 지정해야 합니다."}, {"Keystore.password.must.be.at.least.6.characters", "키 저장소 비밀번호는 6자 이상이어야 합니다."}, {"Enter.keystore.password.", "키 저장소 비밀번호 입력:  "}, {"Enter.source.keystore.password.", "소스 키 저장소 비밀번호 입력:  "}, {"Enter.destination.keystore.password.", "대상 키 저장소 비밀번호 입력:  "}, {"Keystore.password.is.too.short.must.be.at.least.6.characters", "키 저장소 비밀번호가 너무 짧음 - 6자 이상이어야 합니다."}, {"Unknown.Entry.Type", "알 수 없는 항목 유형"}, {"Too.many.failures.Alias.not.changed", "오류가 너무 많습니다. 별칭이 변경되지 않았습니다."}, {"Entry.for.alias.alias.successfully.imported.", "{0} 별칭에 대한 항목이 성공적으로 임포트되었습니다."}, {"Entry.for.alias.alias.not.imported.", "{0} 별칭에 대한 항목이 임포트되지 않았습니다."}, {"Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.", "{0} 별칭에 대한 항목을 임포트하는 중 문제 발생: {1}.\n{0} 별칭에 대한 항목이 임포트되지 않았습니다."}, {"Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled", "임포트 명령 완료: 성공적으로 임포트된 항목은 {0}개, 실패하거나 취소된 항목은 {1}개입니다."}, {"Warning.Overwriting.existing.alias.alias.in.destination.keystore", "경고: 대상 키 저장소에서 기존 별칭 {0}을(를) 겹쳐 쓰는 중"}, {"Existing.entry.alias.alias.exists.overwrite.no.", "기존 항목 별칭 {0}이(가) 존재합니다. 겹쳐 쓰겠습니까? [아니오]:  "}, {"Too.many.failures.try.later", "오류가 너무 많음 - 나중에 시도하십시오."}, {"Certification.request.stored.in.file.filename.", "인증 요청이 <{0}> 파일에 저장되었습니다."}, {"Submit.this.to.your.CA", "CA에게 제출하십시오."}, {"if.alias.not.specified.destalias.srckeypass.and.destkeypass.must.not.be.specified", "별칭을 지정하지 않은 경우 destalias, srckeypass 및 destkeypass를 지정하지 않아야 합니다."}, {"Certificate.stored.in.file.filename.", "인증서가 <{0}> 파일에 저장되었습니다."}, {"Certificate.reply.was.installed.in.keystore", "인증서 회신이 키 저장소에 설치되었습니다."}, {"Certificate.reply.was.not.installed.in.keystore", "인증서 회신이 키 저장소에 설치되지 않았습니다."}, {"Certificate.was.added.to.keystore", "인증서가 키 저장소에 추가되었습니다."}, {"Certificate.was.not.added.to.keystore", "인증서가 키 저장소에 추가되지 않았습니다."}, {".Storing.ksfname.", "[{0}을(를) 저장하는 중]"}, {"alias.has.no.public.key.certificate.", "{0}에 공용 키(인증서)가 없습니다."}, {"Cannot.derive.signature.algorithm", "서명 알고리즘을 파생할 수 없습니다."}, {"Alias.alias.does.not.exist", "<{0}> 별칭이 존재하지 않습니다."}, {"Alias.alias.has.no.certificate", "<{0}> 별칭에 인증서가 없습니다."}, {"Key.pair.not.generated.alias.alias.already.exists", "키 쌍이 생성되지 않았으며 <{0}> 별칭이 존재합니다."}, {"Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for", "다음에 대해 유효 기간이 {3}일인 {0}비트 {1} 키 쌍 및 자체 서명된 인증서({2})를 생성하는 중\n\t: {4}"}, {"Enter.key.password.for.alias.", "<{0}>에 대한 키 비밀번호를 입력하십시오."}, {".RETURN.if.same.as.keystore.password.", "\t(키 저장소 비밀번호와 동일한 경우 Enter 키를 누름):  "}, {"Key.password.is.too.short.must.be.at.least.6.characters", "키 비밀번호가 너무 짧음 - 6자 이상이어야 합니다."}, {"Too.many.failures.key.not.added.to.keystore", "오류가 너무 많음 - 키 저장소에 키가 추가되지 않았습니다."}, {"Destination.alias.dest.already.exists", "대상 별칭 <{0}>이(가) 존재합니다."}, {"Password.is.too.short.must.be.at.least.6.characters", "비밀번호가 너무 짧음 - 6자 이상이어야 합니다."}, {"Too.many.failures.Key.entry.not.cloned", "오류가 너무 많습니다. 키 항목이 복제되지 않았습니다."}, {"key.password.for.alias.", "<{0}>에 대한 키 비밀번호"}, {"Keystore.entry.for.id.getName.already.exists", "<{0}>에 대한 키 저장소 항목이 존재합니다."}, {"Creating.keystore.entry.for.id.getName.", "<{0}>에 대한 키 저장소 항목을 생성하는 중..."}, {"No.entries.from.identity.database.added", "ID 데이터베이스에서 추가된 항목이 없습니다."}, {"Alias.name.alias", "별칭 이름: {0}"}, {"Creation.date.keyStore.getCreationDate.alias.", "생성 날짜: {0,date}"}, {"alias.keyStore.getCreationDate.alias.", "{0}, {1,date}, "}, {"alias.", "{0}, "}, {"Entry.type.type.", "항목 유형: {0}"}, {"Certificate.chain.length.", "인증서 체인 길이: "}, {"Certificate.i.1.", "인증서[{0,number,integer}]:"}, {"Certificate.fingerprint.SHA1.", "인증서 지문(SHA1): "}, {"Keystore.type.", "키 저장소 유형: "}, {"Keystore.provider.", "키 저장소 제공자: "}, {"Your.keystore.contains.keyStore.size.entry", "키 저장소에 {0,number,integer}개의 항목이 포함되어 있습니다."}, {"Your.keystore.contains.keyStore.size.entries", "키 저장소에 {0,number,integer}개의 항목이 포함되어 있습니다."}, {"Failed.to.parse.input", "입력값의 구문 분석을 실패했습니다."}, {"Empty.input", "입력값이 비어 있습니다."}, {"Not.X.509.certificate", "X.509 인증서가 아닙니다."}, {"alias.has.no.public.key", "{0}에 공용 키가 없습니다."}, {"alias.has.no.X.509.certificate", "{0}에 X.509 인증서가 없습니다."}, {"New.certificate.self.signed.", "새 인증서(자체 서명):"}, {"Reply.has.no.certificates", "회신에 인증서가 없습니다."}, {"Certificate.not.imported.alias.alias.already.exists", "인증서가 임포트되지 않았으며 <{0}> 별칭이 존재합니다."}, {"Input.not.an.X.509.certificate", "입력이 X.509 인증서가 아닙니다."}, {"Certificate.already.exists.in.keystore.under.alias.trustalias.", "인증서가 <{0}> 별칭 아래의 키 저장소에 존재합니다."}, {"Do.you.still.want.to.add.it.no.", "추가하겠습니까? [아니오]:  "}, {"Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.", "인증서가 <{0}> 별칭 아래에 있는 시스템 차원의 CA 키 저장소에 존재합니다."}, {"Do.you.still.want.to.add.it.to.your.own.keystore.no.", "고유한 키 저장소에 추가하겠습니까? [아니오]:  "}, {"Trust.this.certificate.no.", "이 인증서를 신뢰합니까? [아니오]:  "}, {"YES", "예"}, {"New.prompt.", "새 {0}: "}, {"Passwords.must.differ", "비밀번호는 달라야 합니다."}, {"Re.enter.new.prompt.", "새 {0} 다시 입력: "}, {"Re.enter.new.password.", "새 비밀번호 다시 입력: "}, {"They.don.t.match.Try.again", "일치하지 않습니다. 다시 시도하십시오."}, {"Enter.prompt.alias.name.", "{0} 별칭 이름 입력:  "}, {"Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.", "새 별칭 이름 입력\t(이 항목에 대한 임포트를 취소하려면 Enter 키를 누름):  "}, {"Enter.alias.name.", "별칭 이름 입력:  "}, {".RETURN.if.same.as.for.otherAlias.", "\t(<{0}>과(와) 동일한 경우 Enter 키를 누름)"}, {".PATTERN.printX509Cert", "소유자: {0}\n발행자: {1}\n일련 번호: {2}\n적합한 시작 날짜: {3}, 종료 날짜: {4}\n인증서 지문:\n\t MD5: {5}\n\t SHA1: {6}\n\t SHA256: {7}\n\t 서명 알고리즘 이름: {8}\n\t 버전: {9}"}, {"What.is.your.first.and.last.name.", "이름과 성을 입력하십시오."}, {"What.is.the.name.of.your.organizational.unit.", "조직 단위 이름을 입력하십시오."}, {"What.is.the.name.of.your.organization.", "조직 이름을 입력하십시오."}, {"What.is.the.name.of.your.City.or.Locality.", "구/군/시 이름을 입력하십시오?"}, {"What.is.the.name.of.your.State.or.Province.", "시/도 이름을 입력하십시오."}, {"What.is.the.two.letter.country.code.for.this.unit.", "이 조직의 두 자리 국가 코드를 입력하십시오."}, {"Is.name.correct.", "{0}이(가) 맞습니까?"}, {"no", "아니오"}, {"yes", "예"}, {"y", "y"}, {".defaultValue.", "  [{0}]:  "}, {"Alias.alias.has.no.key", "<{0}> 별칭에 키가 없습니다."}, {"Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key", "<{0}> 별칭은 전용 키 항목이 아닌 항목 유형을 참조합니다. -keyclone 명령은 전용 키 항목의 복제만 지원합니다."}, {".WARNING.WARNING.WARNING.", "*****************  경고 경고 경고  *****************"}, {"Signer.d.", "서명자 #%d:"}, {"Timestamp.", "시간 기록:"}, {"Signature.", "서명:"}, {"CRLs.", "CRL:"}, {"Certificate.owner.", "인증서 소유자: "}, {"Not.a.signed.jar.file", "서명된 jar 파일이 아닙니다."}, {"No.certificate.from.the.SSL.server", "SSL 서버에서 가져온 인증서가 없습니다."}, {".The.integrity.of.the.information.stored.in.your.keystore.", "* 키 저장소에 저장된 정보의 무결성이  *\n* 확인되지 않았습니다! 무결성을 확인하려면, *\n* 키 저장소 비밀번호를 제공해야 합니다.                  *"}, {".The.integrity.of.the.information.stored.in.the.srckeystore.", "* srckeystore에 저장된 정보의 무결성이  *\n* 확인되지 않았습니다! 무결성을 확인하려면, *\n* srckeystore 비밀번호를 제공해야 합니다.                  *"}, {"Certificate.reply.does.not.contain.public.key.for.alias.", "인증서 회신에 <{0}>에 대한 공용 키가 포함되어 있지 않습니다."}, {"Incomplete.certificate.chain.in.reply", "회신에 불완전한 인증서 체인이 있습니다."}, {"Certificate.chain.in.reply.does.not.verify.", "회신의 인증서 체인이 확인되지 않음: "}, {"Top.level.certificate.in.reply.", "회신에 최상위 레벨 인증서가 있음:\n"}, {".is.not.trusted.", "...을(를) 신뢰할 수 없습니다. "}, {"Install.reply.anyway.no.", "회신을 설치하겠습니까? [아니오]:  "}, {"NO", "아니오"}, {"Public.keys.in.reply.and.keystore.don.t.match", "회신과 키 저장소의 공용 키가 일치하지 않습니다."}, {"Certificate.reply.and.certificate.in.keystore.are.identical", "회신과 키 저장소의 인증서가 동일합니다."}, {"Failed.to.establish.chain.from.reply", "회신의 체인 설정을 실패했습니다."}, {"n", "n"}, {"Wrong.answer.try.again", "잘못된 응답입니다. 다시 시도하십시오."}, {"Secret.key.not.generated.alias.alias.already.exists", "보안 키가 생성되지 않았으며 <{0}> 별칭이 존재합니다."}, {"Please.provide.keysize.for.secret.key.generation", "보안 키를 생성하려면 -keysize를 제공하십시오."}, {"Extensions.", "확장: "}, {".Empty.value.", "(비어 있는 값)"}, {"Extension.Request.", "확장 요청:"}, {"PKCS.10.Certificate.Request.Version.1.0.Subject.s.Public.Key.s.format.s.key.", "PKCS #10 인증서 요청(1.0 버전)\n제목: %s\n공용 키: %s 형식 %s 키\n"}, {"Unknown.keyUsage.type.", "알 수 없는 keyUsage 유형: "}, {"Unknown.extendedkeyUsage.type.", "알 수 없는 extendedkeyUsage 유형: "}, {"Unknown.AccessDescription.type.", "알 수 없는 AccessDescription 유형: "}, {"Unrecognized.GeneralName.type.", "알 수 없는 GeneralName 유형: "}, {"This.extension.cannot.be.marked.as.critical.", "이 확장은 중요한 것으로 표시할 수 없습니다. "}, {"Odd.number.of.hex.digits.found.", "홀수 개의 16진수가 발견됨: "}, {"Unknown.extension.type.", "알 수 없는 확장 유형: "}, {"command.{0}.is.ambiguous.", "{0} 명령이 모호함:"}, {"Warning.A.public.key.for.alias.signers.i.does.not.exist.Make.sure.a.KeyStore.is.properly.configured.", "경고: {0} 별칭에 대한 공용 키가 존재하지 않습니다. 키 저장소가 제대로 구성되어 있는지 확인하십시오."}, {"Warning.Class.not.found.class", "경고: 클래스를 찾을 수 없음: {0}"}, {"Warning.Invalid.argument.s.for.constructor.arg", "경고: 생성자에 대해 부적합한 인수: {0}"}, {"Illegal.Principal.Type.type", "잘못된 주체 유형: {0}"}, {"Illegal.option.option", "잘못된 옵션: {0}"}, {"Usage.policytool.options.", "사용법: policytool [options]"}, {".file.file.policy.file.location", "  [-file <file>]    정책 파일 위치"}, {"New", "새로 만들기"}, {"Open", "열기"}, {"Save", "저장"}, {"Save.As", "다른 이름으로 저장"}, {"View.Warning.Log", "경고 로그 보기"}, {"Exit", "종료"}, {"Add.Policy.Entry", "정책 항목 추가"}, {"Edit.Policy.Entry", "정책 항목 편집"}, {"Remove.Policy.Entry", "정책 항목 제거"}, {"Edit", "편집"}, {"Retain", "유지"}, {"Warning.File.name.may.include.escaped.backslash.characters.It.is.not.necessary.to.escape.backslash.characters.the.tool.escapes", "경고: 파일 이름에 이스케이프된 백슬래시 문자가 포함되었을 수 있습니다. 백슬래시 문자는 이스케이프할 필요가 없습니다. 영구 저장소에 정책 콘텐츠를 쓸 때 필요에 따라 자동으로 문자가 이스케이프됩니다.\n\n입력된 이름을 그대로 유지하려면 [유지]를 누르고, 이름을 편집하려면 [편집]을 누르십시오."}, {"Add.Public.Key.Alias", "공용 키 별칭 추가"}, {"Remove.Public.Key.Alias", "공용 키 별칭 제거"}, {"File", "파일"}, {"KeyStore", "키 저장소"}, {"Policy.File.", "정책 파일:"}, {"Could.not.open.policy.file.policyFile.e.toString.", "정책 파일을 열 수 없음: {0}: {1}"}, {"Policy.Tool", "정책 툴"}, {"Errors.have.occurred.while.opening.the.policy.configuration.View.the.Warning.Log.for.more.information.", "정책 구성을 여는 중 오류가 발생했습니다. 자세한 내용은 경고 로그를 확인하십시오."}, {"Error", "오류"}, {"OK", "확인"}, {"Status", "상태"}, {"Warning", "경고"}, {"Permission.", "권한:                                                       "}, {"Principal.Type.", "주체 유형:"}, {"Principal.Name.", "주체 이름:"}, {"Target.Name.", "대상 이름:                                                    "}, {"Actions.", "작업:                                                             "}, {"OK.to.overwrite.existing.file.filename.", "기존 파일 {0}을(를) 겹쳐 쓰겠습니까?"}, {"Cancel", "취소"}, {"CodeBase.", "CodeBase:"}, {"SignedBy.", "SignedBy:"}, {"Add.Principal", "주체 추가"}, {"Edit.Principal", "주체 편집"}, {"Remove.Principal", "주체 제거"}, {"Principals.", "주체:"}, {".Add.Permission", "  권한 추가"}, {".Edit.Permission", "  권한 편집"}, {"Remove.Permission", "권한 제거"}, {"Done", "완료"}, {"KeyStore.URL.", "키 저장소 URL:"}, {"KeyStore.Type.", "키 저장소 유형:"}, {"KeyStore.Provider.", "키 저장소 제공자:"}, {"KeyStore.Password.URL.", "키 저장소 비밀번호 URL:"}, {"Principals", "주체"}, {".Edit.Principal.", "  주체 편집:"}, {".Add.New.Principal.", "  새 주체 추가:"}, {"Permissions", "권한"}, {".Edit.Permission.", "  권한 편집:"}, {".Add.New.Permission.", "  새 권한 추가:"}, {"Signed.By.", "서명자:"}, {"Cannot.Specify.Principal.with.a.Wildcard.Class.without.a.Wildcard.Name", "와일드 카드 문자 이름 없이 와일드 카드 문자 클래스를 사용하는 주체를 지정할 수 없습니다."}, {"Cannot.Specify.Principal.without.a.Name", "이름 없이 주체를 지정할 수 없습니다."}, {"Permission.and.Target.Name.must.have.a.value", "권한과 대상 이름의 값이 있어야 합니다."}, {"Remove.this.Policy.Entry.", "이 정책 항목을 제거하겠습니까?"}, {"Overwrite.File", "파일 겹쳐쓰기"}, {"Policy.successfully.written.to.filename", "{0}에 성공적으로 정책을 썼습니다."}, {"null.filename", "널 파일 이름"}, {"Save.changes.", "변경 사항을 저장하겠습니까?"}, {"Yes", "예"}, {"No", "아니오"}, {"Policy.Entry", "정책 항목"}, {"Save.Changes", "변경 사항 저장"}, {"No.Policy.Entry.selected", "선택된 정책 항목이 없습니다."}, {"Unable.to.open.KeyStore.ex.toString.", "키 저장소를 열 수 없음: {0}"}, {"No.principal.selected", "선택된 주체가 없습니다."}, {"No.permission.selected", "선택된 권한이 없습니다."}, {"name", "이름"}, {"configuration.type", "구성 유형"}, {"environment.variable.name", "환경 변수 이름"}, {"library.name", "라이브러리 이름"}, {"package.name", "패키지 이름"}, {"policy.type", "정책 유형"}, {"property.name", "속성 이름"}, {"Principal.List", "주체 목록"}, {"Permission.List", "권한 목록"}, {"Code.Base", "코드 베이스"}, {"KeyStore.U.R.L.", "키 저장소 URL:"}, {"KeyStore.Password.U.R.L.", "키 저장소 비밀번호 URL:"}, {"invalid.null.input.s.", "널 입력값이 부적합합니다."}, {"actions.can.only.be.read.", "작업은 '읽기' 전용입니다."}, {"permission.name.name.syntax.invalid.", "권한 이름 [{0}] 구문이 부적합함: "}, {"Credential.Class.not.followed.by.a.Principal.Class.and.Name", "인증서 클래스 다음에 주체 클래스와 이름이 없습니다."}, {"Principal.Class.not.followed.by.a.Principal.Name", "주체 클래스 다음에 주체 이름이 없습니다."}, {"Principal.Name.must.be.surrounded.by.quotes", "주체 이름은 따옴표로 묶어야 합니다."}, {"Principal.Name.missing.end.quote", "주체 이름에 닫는 따옴표가 누락되었습니다."}, {"PrivateCredentialPermission.Principal.Class.can.not.be.a.wildcard.value.if.Principal.Name.is.not.a.wildcard.value", "주체 이름이 와일드 카드 문자(*) 값이 아닌 경우 PrivateCredentialPermission 주체 클래스는 와일드 카드 문자(*) 값일 수 없습니다."}, {"CredOwner.Principal.Class.class.Principal.Name.name", "CredOwner:\n\t주체 클래스 = {0}\n\t주체 이름 = {1}"}, {"provided.null.name", "널 이름을 제공했습니다."}, {"provided.null.keyword.map", "널 키워드 맵을 제공했습니다."}, {"provided.null.OID.map", "널 OID 맵을 제공했습니다."}, {"invalid.null.AccessControlContext.provided", "부적합한 널 AccessControlContext가 제공되었습니다."}, {"invalid.null.action.provided", "부적합한 널 작업이 제공되었습니다."}, {"invalid.null.Class.provided", "부적합한 널 클래스가 제공되었습니다."}, {"Subject.", "제목:\n"}, {".Principal.", "\\주체: "}, {".Public.Credential.", "\t공용 인증서: "}, {".Private.Credentials.inaccessible.", "\t전용 인증서에 액세스할 수 없습니다.\n"}, {".Private.Credential.", "\t전용 인증서: "}, {".Private.Credential.inaccessible.", "\t전용 인증서에 액세스할 수 없습니다.\n"}, {"Subject.is.read.only", "제목이 읽기 전용입니다."}, {"attempting.to.add.an.object.which.is.not.an.instance.of.java.security.Principal.to.a.Subject.s.Principal.Set", "java.security.Principal의 인스턴스가 아닌 객체를 제목의 주체 집합에 추가하려고 시도하는 중"}, {"attempting.to.add.an.object.which.is.not.an.instance.of.class", "{0}의 인스턴스가 아닌 객체를 추가하려고 시도하는 중"}, {"LoginModuleControlFlag.", "LoginModuleControlFlag: "}, {"Invalid.null.input.name", "부적합한 널 입력값: 이름"}, {"No.LoginModules.configured.for.name", "{0}에 대해 구성된 LoginModules가 없습니다."}, {"invalid.null.Subject.provided", "부적합한 널 제목이 제공되었습니다."}, {"invalid.null.CallbackHandler.provided", "부적합한 널 CallbackHandler가 제공되었습니다."}, {"null.subject.logout.called.before.login", "널 제목 - 로그인 전에 로그아웃이 호출되었습니다."}, {"unable.to.instantiate.LoginModule.module.because.it.does.not.provide.a.no.argument.constructor", "인수가 없는 생성자를 제공하지 않아 LoginModule {0}을(를) 인스턴스화할 수 없습니다."}, {"unable.to.instantiate.LoginModule", "LoginModule을 인스턴스화할 수 없습니다."}, {"unable.to.instantiate.LoginModule.", "LoginModule을 인스턴스화할 수 없음: "}, {"unable.to.find.LoginModule.class.", "LoginModule 클래스를 찾을 수 없음: "}, {"unable.to.access.LoginModule.", "LoginModule에 액세스할 수 없음: "}, {"Login.Failure.all.modules.ignored", "로그인 실패: 모든 모듈이 무시되었습니다."}, {"java.security.policy.error.parsing.policy.message", "java.security.policy: {0}의 구문을 분석하는 중 오류 발생:\n\t{1}"}, {"java.security.policy.error.adding.Permission.perm.message", "java.security.policy: {0} 권한을 추가하는 중 오류 발생:\n\t{1}"}, {"java.security.policy.error.adding.Entry.message", "java.security.policy: 항목을 추가하는 중 오류 발생:\n\t{0}"}, {"alias.name.not.provided.pe.name.", "별칭 이름이 제공되지 않습니다({0})."}, {"unable.to.perform.substitution.on.alias.suffix", "{0} 별칭을 대체할 수 없습니다."}, {"substitution.value.prefix.unsupported", "대체 값 {0}은(는) 지원되지 않습니다."}, {"LPARAM", "("}, {"RPARAM", ")"}, {"type.can.t.be.null", "유형은 널일 수 없습니다."}, {"keystorePasswordURL.can.not.be.specified.without.also.specifying.keystore", "키 저장소를 지정하지 않고 keystorePasswordURL을 지정할 수 없습니다."}, {"expected.keystore.type", "키 저장소 유형이 필요합니다."}, {"expected.keystore.provider", "키 저장소 제공자가 필요합니다."}, {"multiple.Codebase.expressions", "Codebase 표현식이 여러 개입니다."}, {"multiple.SignedBy.expressions", "SignedBy 표현식이 여러 개입니다."}, {"SignedBy.has.empty.alias", "SignedBy의 별칭이 비어 있습니다."}, {"can.not.specify.Principal.with.a.wildcard.class.without.a.wildcard.name", "와일드 카드 문자 이름 없이 와일드 카드 문자 클래스를 사용하는 주체를 지정할 수 없습니다."}, {"expected.codeBase.or.SignedBy.or.Principal", "codeBase, SignedBy 또는 주체가 필요합니다."}, {"expected.permission.entry", "권한 항목이 필요합니다."}, {"number.", "숫자 "}, {"expected.expect.read.end.of.file.", "[{0}]이(가) 필요하지만 [파일의 끝]까지 읽었습니다."}, {"expected.read.end.of.file.", "[;]이 필요하지만 [파일의 끝]까지 읽었습니다."}, {"line.number.msg", "{0} 행: {1}"}, {"line.number.expected.expect.found.actual.", "{0} 행: [{1}]이(가) 필요하지만 [{2}]이(가) 발견되었습니다."}, {"null.principalClass.or.principalName", "principalClass 또는 principalName이 널입니다."}, {"PKCS11.Token.providerName.Password.", "PKCS11 토큰 [{0}] 비밀번호: "}, {"unable.to.instantiate.Subject.based.policy", "제목 기반 정책을 인스턴스화할 수 없습니다."}};

   public Object[][] getContents() {
      return contents;
   }
}
